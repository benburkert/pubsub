package pubsub

import (
	"errors"
	"sync"

	"github.com/benburkert/pubsub/abool"
)

var (
	ErrClosed = errors.New("PubSub is closed")
	ErrMaxSub = errors.New("maxSubCount reached")
)

type cell[T any] struct {
	val T
	ch  chan struct{}
}

type PubSub[T any] struct {
	buffer *Buffer[*cell[T]]

	donec chan struct{}
	doneo sync.Once
	doneb abool.Value

	pubwg sync.WaitGroup
	subwg sync.WaitGroup

	submu            sync.Mutex
	subCount, subMax int
}

func New[T any](minBufferSize, maxSubCount int) (*PubSub[T], error) {
	if minBufferSize < 2 {
		return nil, errors.New("minBufferSize must be > 1")
	}

	if maxSubCount < 1 {
		return nil, errors.New("maxSubCount must be > 0")
	}

	return &PubSub[T]{
		buffer: NewBuffer((*cell[T])(nil), minBufferSize, maxSubCount),
		donec:  make(chan struct{}),
		doneb:  abool.New(false),
		subMax: maxSubCount,
	}, nil
}

func (ps *PubSub[T]) Close() {
	ps.doneo.Do(func() {
		ps.doneb.Set()
		ps.buffer.Write(&cell[T]{ch: ps.donec})
		close(ps.donec)
	})

	ps.pubwg.Wait()
	ps.subwg.Wait()
}

func (ps *PubSub[T]) Pub(v T) error {
	if ps.isClosed() {
		return ErrClosed
	}

	ps.buffer.Write(&cell[T]{val: v})
	return nil
}

func (ps *PubSub[T]) PubChan(ch <-chan T) (<-chan struct{}, error) {
	if ps.isClosed() {
		return nil, ErrClosed
	}

	ps.pubwg.Add(1)
	go func() {
		defer ps.pubwg.Done()

		for {
			select {
			case v, ok := <-ch:
				if !ok {
					return
				}
				ps.buffer.Write(&cell[T]{val: v})
			case <-ps.donec:
				for v := range ch {
					ps.buffer.Write(&cell[T]{val: v})
				}
				return
			}
		}
	}()

	return ps.donec, nil
}

func (ps *PubSub[T]) PubSlice(vs []T) error {
	if ps.isClosed() {
		return ErrClosed
	}

	cs := make([]*cell[T], len(vs))
	for i, v := range vs {
		cs[i] = &cell[T]{val: v}
	}

	ps.buffer.WriteSlice(cs)
	return nil
}

func (ps *PubSub[T]) SubChan(ch chan<- T) (chan<- struct{}, error) {
	if ps.isClosed() {
		return nil, ErrClosed
	}
	if !ps.addSub() {
		return nil, ErrMaxSub
	}

	unsubc := make(chan struct{})
	go func() {
		<-unsubc

		ps.buffer.Write(&cell[T]{ch: unsubc})
	}()

	rfn := func(c *cell[T]) bool {
		if c.ch == ps.donec || c.ch == unsubc {
			close(ch)
			ps.delSub()
			return false
		}
		if c.ch == nil {
			ch <- c.val
		}
		return true
	}

	ps.buffer.ReadTo(rfn)
	return unsubc, nil
}

func (ps *PubSub[T]) SubFunc(fn func(T)) (func(), error) {
	if ps.isClosed() {
		return nil, ErrClosed
	}
	if !ps.addSub() {
		return nil, ErrMaxSub
	}

	unsubc := make(chan struct{})
	unsubfn := func() {
		ps.buffer.Write(&cell[T]{ch: unsubc})
	}

	rfn := func(c *cell[T]) bool {
		if c.ch == ps.donec || c.ch == unsubc {
			ps.delSub()
			return false
		}
		if c.ch == nil {
			fn(c.val)
		}
		return true
	}

	ps.buffer.ReadTo(rfn)
	return unsubfn, nil
}

func (ps *PubSub[T]) addSub() bool {
	ps.submu.Lock()
	defer ps.submu.Unlock()

	if ps.subCount == ps.subMax {
		return false
	}

	ps.subCount++
	ps.subwg.Add(1)
	return true
}

func (ps *PubSub[T]) delSub() {
	ps.submu.Lock()
	defer ps.submu.Unlock()

	ps.subCount--
	ps.subwg.Done()
}

func (ps *PubSub[T]) isClosed() bool {
	return ps.doneb.Test()
}
