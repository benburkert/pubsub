package pubsub

import (
	"math"
	"sync"

	"github.com/benburkert/pubsub/cursor"
)

type ReaderFunc[T comparable] func(T) bool

type Buffer[T comparable] struct {
	mu    sync.RWMutex
	data  []T
	empty T

	wcond   *sync.Cond
	wcursor *cursor.Cursor

	rcond    *sync.Cond
	rcursors cursor.Slice
}

func NewBuffer[T comparable](empty T, minSize, maxReaders int) *Buffer[T] {
	size := CalcBufferSize(minSize)
	mask := size - 1

	b := &Buffer[T]{
		data:     make([]T, size),
		empty:    empty,
		wcursor:  cursor.New(0, mask),
		rcursors: cursor.MakeSlice(maxReaders, mask),
	}

	for i := range b.data {
		b.data[i] = empty
	}

	b.wcond = sync.NewCond(&b.mu)
	b.rcond = sync.NewCond(b.mu.RLocker())
	return b
}

func (b *Buffer[T]) FullReadTo(rfn ReaderFunc[T]) []T {
	b.mu.RLock() // unlocked in readTo

	c := b.getCursor() // reset in readTo
	s := b.read(c)

	go b.readTo(c, rfn)
	return s
}

func (b *Buffer[T]) Read() []T {
	b.mu.RLock()
	defer b.mu.RUnlock()

	c := b.getCursor()
	defer c.Reset()

	return b.read(c)
}

func (b *Buffer[T]) ReadTo(rfn ReaderFunc[T]) {
	b.mu.RLock() // unlocked in readTo

	go b.readTo(b.getCursor(), rfn)
}

func (b *Buffer[T]) Write(v T) {
	b.mu.Lock()
	defer b.mu.Unlock()

	b.write(v)
}

func (b *Buffer[T]) WriteSlice(vs []T) {
	b.mu.Lock()
	defer b.mu.Unlock()

	for _, v := range vs {
		b.write(v)
	}
}

// assumes b.mu RLock held
func (b *Buffer[T]) getCursor() *cursor.Cursor {
	return b.rcursors.Alloc(b.wcursor.Pos())
}

// assumes b.mu Rlock held
func (b *Buffer[T]) read(c *cursor.Cursor) []T {
	rpos := c.Pos()
	if b.data[rpos] == b.empty {
		s := make([]T, rpos)
		copy(s, b.data[:rpos])
		return s
	}

	size := int(len(b.data))
	s := make([]T, size)
	copy(s[:(size-rpos)], b.data[rpos:])
	copy(s[(size-rpos):], b.data[:rpos])
	return s
}

// assumes b.mu RLock held
func (b *Buffer[T]) readBarrier(c *cursor.Cursor) bool {
	return c.Pos() == b.wcursor.Pos()
}

// asumes b.mu RLock held
func (b *Buffer[T]) readTo(c *cursor.Cursor, rfn ReaderFunc[T]) {
	defer b.mu.RUnlock()
	defer b.wcond.Signal()
	defer c.Reset()

	for {
		for b.readBarrier(c) {
			b.rcond.Wait()
		}

		rpos, wpos := c.Pos(), b.wcursor.Pos()
		for rpos != wpos {
			if !rfn(b.data[rpos]) {
				return
			}
			rpos = c.Inc()
		}
		b.wcond.Signal()
	}
}

// asumes b.mu Lock held
func (b *Buffer[T]) write(v T) {
	for b.writeBarrier() {
		b.wcond.Wait()
	}

	wpos := b.wcursor.Pos()
	b.data[wpos] = v
	b.wcursor.Inc()

	b.rcond.Broadcast()
}

// assumes b.mu Lock held
func (b *Buffer[T]) writeBarrier() bool {
	npos := b.wcursor.Next()
	for _, c := range b.rcursors {
		if npos == c.Pos() {
			return true
		}
	}
	return false
}

func CalcBufferSize(minSize int) int {
	return int(math.Pow(2, math.Ceil(math.Log2(float64(minSize)))))
}
