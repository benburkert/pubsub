package pubsub

import (
	"reflect"
	"runtime"
	"strconv"
	"sync"
	"testing"
	"unsafe"
)

var (
	ints   = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
	floats = []float64{
		0.12345, 1.2345, 12.345, 123.45, 1234.5,
		5.43210, 54.321, 543.21, 5432.1,
	}
	strings = []string{"A", "B", "C", "D", "E", "F", "G", "H", "I"}

	structs = []testStruct{
		{i: 1, f: 0.12345, s: "A"},
		{i: 2, f: 1.2345, s: "B"},
		{i: 3, f: 12.345, s: "C"},
		{i: 4, f: 123.45, s: "D"},
		{i: 5, f: 1234.5, s: "E"},
		{i: 6, f: 5.4321, s: "F"},
		{i: 7, f: 54.321, s: "G"},
		{i: 8, f: 543.21, s: "H"},
		{i: 9, f: 5432.1, s: "I"},
	}

	pointers = []*testStruct{
		&testStruct{i: 1, f: 0.12345, s: "A"},
		&testStruct{i: 2, f: 1.2345, s: "B"},
		&testStruct{i: 3, f: 12.345, s: "C"},
		&testStruct{i: 4, f: 123.45, s: "D"},
		&testStruct{i: 5, f: 1234.5, s: "E"},
		&testStruct{i: 6, f: 5.4321, s: "F"},
		&testStruct{i: 7, f: 54.321, s: "G"},
		&testStruct{i: 8, f: 543.21, s: "H"},
		&testStruct{i: 9, f: 5432.1, s: "I"},
	}
)

type testStruct struct {
	i int
	f float64
	s string
}

type testCase[T comparable] struct {
	buf *Buffer[T]

	vals []T
}

func TestBufferWrite(t *testing.T) {
	t.Run("int", testCase[int]{NewBuffer(0, 4, 1), ints}.testBufferWrite)
	t.Run("float", testCase[float64]{NewBuffer(0.0, 4, 1), floats}.testBufferWrite)
	t.Run("strings", testCase[string]{NewBuffer("", 4, 1), strings}.testBufferWrite)
	t.Run("structs", testCase[testStruct]{NewBuffer(testStruct{}, 4, 1), structs}.testBufferWrite)
	t.Run("pointers", testCase[*testStruct]{NewBuffer((*testStruct)(nil), 4, 1), pointers}.testBufferWrite)
}

func (tc testCase[T]) testBufferWrite(t *testing.T) {
	t.Parallel()

	want := []T{}
	if got := tc.buf.Read(); !reflect.DeepEqual(want, got) {
		t.Errorf("want empty buffer read %v, got %v", want, got)
	}

	tc.buf.Write(tc.vals[0])
	if want, got := tc.vals[:1], tc.buf.Read(); !reflect.DeepEqual(want, got) {
		t.Errorf("want sparse buffer read %#v, got %#v", want, got)
	}

	tc.buf.Write(tc.vals[1])
	tc.buf.Write(tc.vals[2])
	if want, got := tc.vals[:3], tc.buf.Read(); !reflect.DeepEqual(want, got) {
		t.Errorf("want full buffer read %v, got %v", want, got)
	}

	tc.buf.Write(tc.vals[3])
	tc.buf.Write(tc.vals[4])
	if want, got := tc.vals[1:5], tc.buf.Read(); !reflect.DeepEqual(want, got) {
		t.Errorf("want wrapped buffer read %v, got %v", want, got)
	}
}

func TestBufferReadTo(t *testing.T) {
	t.Run("int", testCase[int]{NewBuffer(0, 4, 1), ints}.testBufferReadTo)
	t.Run("float", testCase[float64]{NewBuffer(0.0, 4, 1), floats}.testBufferReadTo)
	t.Run("strings", testCase[string]{NewBuffer("", 4, 1), strings}.testBufferReadTo)
	t.Run("structs", testCase[testStruct]{NewBuffer(testStruct{}, 4, 1), structs}.testBufferReadTo)
	t.Run("pointers", testCase[*testStruct]{NewBuffer((*testStruct)(nil), 4, 1), pointers}.testBufferReadTo)
}

func (tc testCase[T]) testBufferReadTo(t *testing.T) {
	t.Parallel()

	buffer := tc.buf
	donec := make(chan struct{})
	want := tc.vals

	got := []T{}
	rfn := func(v T) bool {
		got = append(got, v)
		if len(got) == len(want) {
			close(donec)
			return false
		}
		return true
	}
	buffer.ReadTo(rfn)

	for _, v := range want {
		buffer.Write(v)
	}

	<-donec
	if !reflect.DeepEqual(want, got) {
		t.Errorf("want buffer read to %v, got %v", want, got)
	}
}

func TestBufferWriteSlice(t *testing.T) {
	t.Run("int", testCase[int]{NewBuffer(0, 4, 1), ints[:5]}.testBufferWriteSlice)
	t.Run("float", testCase[float64]{NewBuffer(0.0, 4, 1), floats[:5]}.testBufferWriteSlice)
	t.Run("strings", testCase[string]{NewBuffer("", 8, 1), strings}.testBufferWriteSlice)
	t.Run("structs", testCase[testStruct]{NewBuffer(testStruct{}, 4, 1), structs[:5]}.testBufferWriteSlice)
	t.Run("pointers", testCase[*testStruct]{NewBuffer((*testStruct)(nil), 8, 1), pointers}.testBufferWriteSlice)
}

func (tc testCase[T]) testBufferWriteSlice(t *testing.T) {
	t.Parallel()

	buffer := tc.buf
	donec := make(chan struct{})
	want := tc.vals

	got := []T{}
	rfn := func(v T) bool {
		got = append(got, v)
		if len(got) == len(want) {
			close(donec)
			return false
		}
		return true
	}
	buffer.ReadTo(rfn)

	buffer.WriteSlice(want)

	<-donec
	if !reflect.DeepEqual(want, got) {
		t.Errorf("want buffer read to %v, got %v", want, got)
	}

	got = buffer.Read()
	if !reflect.DeepEqual(want[1:], got) {
		t.Errorf("want buffer read %v, got %v", want[1:], got)
	}
}

func TestBufferFullReadTo(t *testing.T) {
	t.Run("int", testCase[int]{NewBuffer(0, 4, 1), ints}.testBufferFullReadTo)
	t.Run("strings", testCase[string]{NewBuffer("", 4, 1), strings}.testBufferFullReadTo)
	t.Run("float", testCase[float64]{NewBuffer(0.0, 4, 1), floats}.testBufferFullReadTo)
	t.Run("structs", testCase[testStruct]{NewBuffer(testStruct{}, 4, 1), structs}.testBufferFullReadTo)
	t.Run("pointers", testCase[*testStruct]{NewBuffer((*testStruct)(nil), 4, 1), pointers}.testBufferFullReadTo)
}

func (tc testCase[T]) testBufferFullReadTo(t *testing.T) {
	t.Parallel()

	buffer := tc.buf
	donec := make(chan struct{})
	data := tc.vals

	buffer.WriteSlice(data[:5])

	got := []T{}
	rfn := func(v T) bool {
		got = append(got, v)
		if len(got) == len(data[5:]) {
			close(donec)
			return false
		}
		return true
	}

	want := data[1:5]
	if s := buffer.FullReadTo(rfn); !reflect.DeepEqual(want, s) {
		t.Errorf("want full read %v, got %v", want, s)
	}

	buffer.WriteSlice(data[5:])

	<-donec
	want = data[5:]
	if !reflect.DeepEqual(want, got) {
		t.Errorf("want full read func %v, got %v", want, got)
	}

}

func TestConcurrentReadTo(t *testing.T) {
	n, m := 1024, runtime.NumCPU()-1

	ints := make([]int, n*m)
	for i := range ints {
		ints[i] = i
	}

	t.Run("int", testCase[int]{NewBuffer(^0, n, m), ints}.testConcurrentReadTo)

	strings := make([]string, n*m)
	for i := range strings {
		strings[i] = strconv.Itoa(i)
	}

	t.Run("strings", testCase[string]{NewBuffer("", n, m), strings}.testConcurrentReadTo)
	t.Run("float", testCase[float64]{NewBuffer(0.0, n, m), floats}.testConcurrentReadTo)
	t.Run("structs", testCase[testStruct]{NewBuffer(testStruct{}, n, m), structs}.testConcurrentReadTo)
	t.Run("pointers", testCase[*testStruct]{NewBuffer((*testStruct)(nil), n, m), pointers}.testConcurrentReadTo)
}

func (tc testCase[T]) testConcurrentReadTo(t *testing.T) {
	m := runtime.NumCPU() - 1

	buffer := tc.buf
	data := tc.vals

	gots := make([][]T, m)

	readywg := sync.WaitGroup{}
	readywg.Add(m)

	donewg := sync.WaitGroup{}
	donewg.Add(m)

	for i := range gots {
		go func(i int) {
			got := make([]T, 0, len(data))
			rfn := func(v T) bool {
				got = append(got, v)
				if len(got) == len(data) {
					gots[i] = got
					donewg.Done()
					return false
				}
				return true
			}

			buffer.ReadTo(rfn)
			readywg.Done()
		}(i)
	}

	readywg.Wait()
	buffer.WriteSlice(data)
	donewg.Wait()

	for _, got := range gots {
		if !reflect.DeepEqual(data, got) {
			t.Errorf("want buffer read to %v, got %v", data, got)
		}
	}
}

func BenchmarkBuffer(b *testing.B) {
	b.Run("Small", bufferBench{0.5, 0}.bench)
	b.Run("Medium", bufferBench{1, 1}.bench)
	b.Run("Large", bufferBench{2, 0}.bench)
}

type bufferBench struct {
	x float64
	y int
}

func (bb bufferBench) bench(b *testing.B) {
	n := (int(float64(b.N)*bb.x) + bb.y) / 2
	if n < 2 {
		n = 2
	}

	m := runtime.GOMAXPROCS(-1)
	buffer := NewBuffer(0, n, m)

	data := make([]int, b.N)
	for i := range data {
		data[i] = i
	}

	donewg := sync.WaitGroup{}
	donewg.Add(m)

	for i := 0; i < m; i++ {
		go func() {
			defer donewg.Done()
			count := 0
			buffer.ReadTo(func(_ int) bool {
				count++
				return count == len(data)
			})
		}()
	}

	b.SetBytes(int64(m * int(unsafe.Sizeof(data[0]))))
	b.ReportAllocs()
	b.ResetTimer()

	buffer.WriteSlice(data)
	donewg.Wait()
}
