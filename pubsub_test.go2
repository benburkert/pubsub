package pubsub

import (
	"fmt"
	"reflect"
	"sync"
	"sync/atomic"
	"testing"
)

func TestPubSubErrors(t *testing.T) {
	if _, err := New[int](1, 1); err == nil {
		t.Error("expected error for minBufferSize=1")
	}
	if _, err := New[int](2, 0); err == nil {
		t.Error("expected error for maxSubCount=0")
	}

	ps, err := New[int](2, 1)
	if err != nil {
		t.Fatal(err)
	}

	if _, err = ps.SubChan(make(chan int)); err != nil {
		t.Fatal(err)
	}
	if _, err = ps.SubChan(make(chan int)); err != ErrMaxSub {
		t.Errorf("unexpected error %q", err)
	}

	ps.Close()
	if _, err = ps.SubChan(make(chan int)); err != ErrClosed {
		t.Errorf("unexpected error %q", err)
	}
}

func TestPubSubFuncs(t *testing.T) {
	ps, err := New[struct{}](4, 2)
	if err != nil {
		t.Fatal(err)
	}
	defer ps.Close()

	counter := new(int32)
	fn := func(struct{}) { atomic.AddInt32(counter, 1) }

	if _, err := ps.SubFunc(fn); err != nil {
		t.Fatal(err)
	}
	if _, err := ps.SubFunc(fn); err != nil {
		t.Fatal(err)
	}

	for i := 0; i < 16; i++ {
		ps.Pub(struct{}{})
	}

	if count := atomic.LoadInt32(counter); count != 32 {
		fmt.Errorf("want count=32, got %d", count)
	}
}

func TestPubSubChans(t *testing.T) {
	ps, err := New[struct{}](4, 2)
	if err != nil {
		t.Fatal(err)
	}
	defer ps.Close()

	wg := &sync.WaitGroup{}
	wg.Add(32)

	for i := 0; i < 2; i++ {
		ch := make(chan struct{})
		go func(ch <-chan struct{}) {
			for range ch {
				wg.Done()
			}
		}(ch)
		if _, err := ps.SubChan(ch); err != nil {
			t.Fatal(err)
		}
	}

	for i := 0; i < 16; i++ {
		ps.Pub(struct{}{})
	}

	wg.Wait()
}

func TestPubSubMixed(t *testing.T) {
	ps, err := New[struct{}](4, 2)
	if err != nil {
		t.Fatal(err)
	}
	defer ps.Close()

	wg := &sync.WaitGroup{}
	wg.Add(32)

	counter := new(int32)
	fn := func(struct{}) {
		atomic.AddInt32(counter, 1)
		wg.Done()
	}

	if _, err := ps.SubFunc(fn); err != nil {
		t.Fatal(err)
	}

	ch := make(chan struct{})
	go func() {
		for v := range ch {
			fn(v)
		}
	}()

	if _, err := ps.SubChan(ch); err != nil {
		t.Fatal(err)
	}

	for i := 0; i < 16; i++ {
		ps.Pub(struct{}{})
	}

	wg.Wait()
	if count := atomic.LoadInt32(counter); count != 32 {
		fmt.Errorf("want count=32, got %d", count)
	}
}

func TestPubSubFuncUnsubscribe(t *testing.T) {
	ps, err := New[struct{}](4, 2)
	if err != nil {
		t.Fatal(err)
	}
	defer ps.Close()

	var unsubfn func()
	count := 0
	stepper := make(chan struct{})
	subfn := func(struct{}) {
		if count == 5 {
			go func() {
				unsubfn()
				close(stepper)
			}()

			return
		}
		if count > 5 {
			t.Error("value recieved after unsubscribing")
			return
		}
		stepper <- struct{}{}
		count++
	}

	if unsubfn, err = ps.SubFunc(subfn); err != nil {
		t.Fatal(err)
	}

	go func() { stepper <- struct{}{} }()
	for i := 0; i <= 10; i++ {
		<-stepper
		ps.Pub(struct{}{})
	}
}

func TestPubSubChanUnsubscribe(t *testing.T) {
	ps, err := New[struct{}](4, 2)
	if err != nil {
		t.Fatal(err)
	}
	defer ps.Close()

	ch := make(chan struct{})
	unsubch, err := ps.SubChan(ch)
	if err != nil {
		t.Fatal(err)
	}

	donec := make(chan struct{})
	go func() {
		count := 0
		for range ch {
			if count == 5 {
				close(unsubch)
			}
			count++
		}
		close(donec)
	}()

	for i := 0; i < 10; i++ {
		ps.Pub(struct{}{})
	}
	<-donec
}

func TestNonComparableType(t *testing.T) {
	ps, err := New[map[string]struct{}](4, 2)
	if err != nil {
		t.Fatal(err)
	}

	ch := make(chan map[string]struct{}, 1)
	if _, err = ps.SubChan(ch); err != nil {
		t.Fatal(err)
	}

	val := map[string]struct{}{
		"foo": struct{}{},
		"bar": struct{}{},
	}

	if err := ps.Pub(val); err != nil {
		t.Fatal(err)
	}
	ps.Close()

	if want, got := val, <-ch; !reflect.DeepEqual(want, got) {
		t.Fatalf("want map %q, got %q", want, got)
	}
	if _, ok := <-ch; ok {
		t.Fatal("expected subscriber chan to be closed")
	}
}
